Хапаючи золоте кільце-0
Linux надає потужний і обширний API для додатків, але іноді цього недостатньо. Взаємодія з апаратним забезпеченням або виконання операцій, що вимагають доступу до привілейованої інформації в системі, потребують модуля ядра.

Модуль ядра Linux — це частина скомпільованого бінарного коду, яка вставляється безпосередньо в ядро Linux і працює в кільці 0, найнижчому і найменш захищеному кільці виконання в процесорі x86-64. Код тут працює повністю без перевірок, але працює з неймовірною швидкістю і має доступ до всього в системі.

Не для звичайних смертних
Написання модуля ядра Linux — не для слабкодухих. Змінюючи ядро, ви ризикуєте втратити дані та пошкодити систему. Код ядра не має звичайної страховки, якою користуються звичайні додатки Linux. Якщо у вас виникне помилка, це заблокує всю систему.

Гірше того, ваша проблема може не проявитися одразу. Блокування вашого модуля одразу після завантаження - це, мабуть, найкращий сценарій невдачі. Додаючи більше коду до вашого модуля, ви ризикуєте створити неконтрольовані цикли та витоки пам'яті. Якщо не бути обережним, це може продовжувати рости під час роботи вашої машини. Зрештою, важливі структури пам'яті і навіть буфери можуть бути перезаписані.

Традиційні парадигми розробки додатків можуть бути значною мірою відкинуті. Окрім завантаження та вивантаження вашого модуля, ви писатимете код, який реагує на системні події, а не працює за послідовним шаблоном. При розробці ядра ви пишете API, а не самі додатки.

У вас також немає доступу до стандартної бібліотеки. Хоча ядро надає деякі функції, як-от 
```sh printk ```
 (що служить заміною printf) і kmalloc (який працює подібно до malloc), ви здебільшого залишаєтесь залежні від власних засобів. Крім того, коли ваш модуль вивантажується, ви відповідаєте за повне очищення після себе. Збирання сміття відсутнє.

Передумови
Перш ніж ми почнемо, нам потрібно переконатися, що у нас є правильні інструменти для роботи. Найголовніше, вам знадобиться Linux-машина. Знаю, це повна несподіванка! Хоча підійде будь-який дистрибутив Linux, у цьому прикладі я використовую Ubuntu 16.04 LTS, тому якщо ви користуєтесь іншим дистрибутивом, вам, можливо, доведеться трохи скоригувати команди встановлення.

По-друге, вам знадобиться або окрема фізична машина, або віртуальна машина. Я віддаю перевагу роботі у віртуальній машині, але це повністю на ваш розсуд. Я не раджу використовувати вашу основну машину, оскільки втрата даних може статися, коли ви зробите помилку. Я кажу коли, а не якщо, тому що ви, безсумнівно, заблокуєте свою машину принаймні кілька разів під час процесу. Ваші останні зміни коду можуть все ще бути в буфері запису, коли ядро панікує, тому можливо, що ваші вихідні файли можуть бути пошкоджені. Тестування у віртуальній машині усуває цей ризик.

І нарешті, вам потрібно знати хоча б трохи C. Середовище виконання C++ занадто велике для ядра, тому написання "голого" C є необхідним. Для взаємодії з апаратним забезпеченням знання деякого асемблера може бути корисним.

Встановлення середовища розробки
На Ubuntu нам потрібно виконати:

```sh apt-get install build-essential linux-headers-`uname -r` ```
Це встановить основні інструменти розробки та заголовки ядра, необхідні для цього прикладу.

Приклади нижче припускають, що ви працюєте як звичайний користувач, а не як root, але у вас є привілеї sudo. Sudo є обов'язковим для завантаження модулів ядра, але ми хочемо працювати поза root, коли це можливо.
вже існує чудовий список потенційних цілей: syscalls! Системні виклики (або system calls) - це функції ядра, які можна викликати з простору користувача, і вони необхідні для майже всього, що віддалено цікаве. Кілька поширених, про які ви, ймовірно, чули:

open
read
write
close
execve
fork
kill
mkdir
Повний список системних викликів x86_64 можна побачити тут. Додавання власної функціональності до будь-якої з цих функцій може бути дуже цікавим. Ми могли б перехоплювати виклики read до певних файлів і повертати щось інше, або додавати користувацькі змінні середовища за допомогою execve. Ми навіть могли б використовувати деякі невикористані сигнали в kill, щоб надсилати команди нашому rootkit для виконання певних дій.

Але спочатку корисно мати краще уявлення про те, як ми робимо системний виклик із простору користувача - зрештою, саме цей процес ми сподіваємося перехопити!