Linux Security API
Найбільш правильним було б використання Linux Security API – спеціального інтерфейсу, створеного саме для цього. У критичних місцях ядерного коду розташовані виклики security-функцій, які викликають коллбеки, встановлені security-модулем. Security-модуль може вивчати контекст операції та приймати рішення про її вирішення чи заборону.

На жаль, у Linux Security API є кілька важливих обмежень:

security-модулі не можуть бути завантажені динамічно, є частиною ядра і вимагають його перескладання у системі може бути лише один security-модуль (з невеликими винятками) Якщо з приводу множинності модулів позиція розробників ядра неоднозначна, то заборона на динамічне завантаження принципова: security-модуль повинен бути частиною ядра, щоб гарантувати безпеку постійно, з моменту завантаження.

Таким чином, для використання Security API необхідно постачати власне складання ядра, а також інтегрувати додатковий модуль із SELinux або AppArmor, які використовуються популярними дистрибутивами. Замовник на подібні зобов'язання підписуватись не хотів, тому цей шлях виявився закритим.

Модифікація таблиці системних викликів
Моніторинг був потрібний в основному для дій, що виконуються користувачами додатками, так що в принципі міг би бути реалізований на рівні системних викликів. Як відомо, Linux зберігає всі обробники системних викликів у таблиці sys_call_table. Підміна значень у цій таблиці призводить до зміни поведінки всієї системи. Таким чином, зберігши старе значення оброблювача і підставивши таблицю власний оброблювач, ми можемо перехопити будь-який системний виклик.

Цей підхід має певні переваги:

Повний контроль над будь-якими системними викликами - єдиним інтерфейсом до ядра у додатків користувача. Використовуючи його ми можемо бути впевнені, що не пропустимо якусь важливу дію, що виконується процесом користувача. Мінімальні витрати. Є одноразові капітальні вкладення під час оновлення таблиці системних викликів. Окрім неминучого корисного навантаження моніторингу, єдиною витратою є зайвий виклик функції (для виклику оригінального обробника системного виклику). Мінімальні вимоги до ядра. За бажання цей підхід не вимагає будь-яких додаткових конфігураційних опцій в ядрі, так що теоретично підтримує максимально широкий спектр систем.

Однак він також страждає від деяких недоліків:

Технічна складність реалізації. Сама собою заміна покажчиків у таблиці не становить труднощів. Але супутні завдання вимагають неочевидних рішень та певної кваліфікації: пошук таблиці системних викликів обхід захисту від модифікації таблиці атомарне та безпечне виконання заміни

Це все цікаві речі, але вони вимагають дорогоцінного часу розробників спочатку на реалізацію, а потім на підтримку та розуміння. Неможливість перехоплення деяких оброблювачів. У ядрах до версії 4.16 обробка системних викликів для архітектури x86_64 містила низку оптимізації. Деякі з них вимагали того, що обробник системного виклику був спеціальним перехідником, реалізованим на асемблері. Відповідно, подібні обробники часом складно, а іноді й зовсім неможливо замінити на свої, написані на Сі. Більше того, у різних версіях ядра використовуються різні оптимізації, що додає до скарбнички технічних складнощів. Перехоплюються лише системні дзвінки. Цей підхід дозволяє замінювати обробники системних викликів, що обмежує точки входу лише ними. Всі додаткові перевірки виконуються або на початку, або в кінці, і ми маємо лише аргументи системного виклику та його значення, що повертається. Іноді це призводить до необхідності дублювати перевірки на адекватність аргументів та перевірки доступу. Іноді викликає зайві накладні витрати, коли потрібно двічі копіювати пам'ять процесу користувача: якщо аргумент передається через покажчик, то його спочатку доведеться скопіювати нам самим, потім оригінальний обробник скопіює аргумент ще раз для себе. Крім того, в деяких випадках системні виклики надають занадто низьку гранулярність подій, які доводиться додатково відфільтровувати від шуму.

Використання kprobes
Одним з варіантів, які розглядалися, було використання kprobes : спеціалізованого API, в першу чергу призначеного для налагодження та трасування ядра. Цей інтерфейс дозволяє встановлювати перед- та постобробники для будь-якої інструкції в ядрі, а також обробники на вхід та повернення з функції. Обробники отримують доступ до регістрів та можуть їх змінювати. Таким чином, ми могли б отримати як моніторинг, так і можливість впливати на подальший хід роботи.

Переваги, які дає використання kprobes для перехоплення:

Зрілі API. Kprobes існують і покращуються з незапам'ятних часів (2002 рік). Вони мають добре задокументований інтерфейс, більшість підводних каменів вже знайдено, їхня робота по можливості оптимізована, і так далі. Загалом ціла гора переваг над експериментальними самописними велосипедами. Перехоплення будь-якого місця в ядрі. Kprobes реалізуються за допомогою точок зупинки (інструкції int3), що впроваджуються у здійсненний код ядра. Це дозволяє встановлювати kprobes в будь-якому місці будь-якої функції, якщо воно відомо. Аналогічно, kretprobes реалізуються через заміну адреси повернення на стеку і дозволяють перехопити повернення з будь-якої функції (за винятком тих, які управління в принципі не повертають).

Недоліки kprobes:

Технічна складність. Kprobes - це тільки спосіб встановити точку зупинки в будь-якому місці ядра. Для отримання аргументів функції чи значень локальних змінних треба знати, у яких регістрах чи де на стеку вони лежать, і їх звідти витягувати. Для блокування виклику функції необхідно вручну модифікувати стан процесу так, щоб процесор подумав, що він повернув управління з функції. Jprobes оголошено застарілими. Jprobes – це надбудова над kprobes, що дозволяє зручно перехоплювати дзвінки функцій. Вона самостійно витягне аргументи функції з регістрів або стека і викличе ваш обробник, який повинен мати ту ж сигнатуру, що і функція, що перехоплюється. Підступ у тому, що jprobes оголошені застарілими і вирізані з сучасних ядер. Нетривіальні накладні витрати. Розстановка точок зупинки дорога, але вона виконується одноразово. Точки зупинки не впливають на інші функції, проте їхня обробка відносно недешева. На щастя, для архітектури x86_64 реалізована jump-оптимізація, що істотно зменшує вартість kprobes, але вона все ще залишається більшою, ніж, наприклад, при модифікації таблиці системних викликів. Обмеження кретіввипробовують. Kretprobes реалізуються через заміну адреси повернення на стеку. Відповідно, їм необхідно десь зберігати оригінальну адресу, щоб повернутися туди після обробки кретупроби. Адреси зберігаються у буфері фіксованого розміру. У разі його переповнення, коли в системі виконується занадто багато одночасних викликів перехопленої функції, kretprobes буде пропускати спрацьовування. Вимкнене витіснення. Так як kprobes ґрунтується на перериваннях і жонглює регістрами процесора, то для синхронізації всі обробники виконуються з відключеним витісненням (preemption). Це накладає певні обмеження на обробники: у них не можна чекати — виділяти багато пам'яті, займатися введенням-виводом, спати в таймерах та семафорах та інші відомі речі.

Сплайсинг
Для повноти картини варто також описати класичний спосіб перехоплення функцій, який полягає у заміні інструкцій на початку функції на безумовний перехід, що веде наш обробник. Оригінальні інструкції переносяться в інше місце та виконуються перед переходом назад у перехоплену функцію. За допомогою двох переходів ми вшиваємо (splice in) свій додатковий код у функцію, тому такий підхід називається сплайсингом .

Саме таким чином і реалізується jump-оптимізація для kprobes. Використовуючи сплайсинг можна досягти тих же результатів, але без додаткових витрат на kprobes і з повним контролем ситуації.

Переваги сплайсингу очевидні:

Мінімальні вимоги до ядра. Сплайсинг не вимагає особливих опцій в ядрі і працює на початку будь-якої функції. Потрібно лише знати її адресу. Мінімальні витрати. Два безумовні переходи — ось і всі дії, які треба виконати перехопленому коду, щоб передати керування обробнику та назад. Подібні переходи добре передбачаються процесором і є дуже дешевими.

Проте, головний недолік цього підходу серйозно затьмарює картину:

Технічна складність. Вона зашкалює. Не можна просто так взяти та переписати машинний код. Ось короткий і неповний список завдань, які доведеться вирішити: синхронізація установки та зняття перехоплення (що якщо функцію викличуть прямо в процесі заміни її інструкцій?) обхід захисту на модифікацію регіонів пам'яті з кодом інвалідність кешів процесора після заміни інструкцій дизасемблювання замінних інструкцій, щоб скопіювати їх цілими перевірка на відсутність переходів усередину замінного шматка перевірка на можливість перемістити замінний шматок в інше місце

Так, можна підглядати в kprobes і використовувати внутрішньоядерний фреймворк livepatch, але підсумкове рішення все одно залишається досить складним. Страшно уявити, скільки сплячих проблем буде в кожній новій його реалізації.

Ftrace - це фреймворк для трасування ядра на рівні функцій. Він розробляється з 2008 року і володіє просто фантастичним інтерфейсом для програм користувача. Ftrace дозволяє відстежувати частоту і тривалість викликів функцій, відображати графи викликів, фільтрувати функції, що цікавлять, за шаблонами, і так далі. Про можливості ftrace можна почати читати звідси , і далі за наведеними посиланнями та офіційною документацією.
Реалізується ftrace на основі ключів компілятора -pgі -mfentry, які вставляють на початок кожної функції виклик спеціальної функції трасування mcount() або fentry(). Зазвичай, у програмах користувача ця можливість компілятора використовується профільниками, щоб відстежувати виклики всіх функцій. Ядро використовує ці функції для реалізації фреймворку ftrace.

Викликати ftrace з кожної функції - це, зрозуміло, недешево, тому для популярних архітектур доступна оптимізація: динамічний ftrace . Суть у тому, що ядро ​​знає розташування всіх викликів mcount() або fentry() і на ранніх етапах завантаження замінює їх машинний код на nop - спеціальну інструкцію, що нічого не робить. При включенні трасування до потрібних функцій виклики ftrace додаються назад. Таким чином, якщо ftrace не використовується, його вплив на систему мінімально.
Опис потрібних функцій

Кожну функцію, що перехоплюється, можна описати наступною структурою:
```sh
/**
 * struct ftrace_hook - описує перехоплюєму функцію
 *
 * @name:       Ім'я функції яку перехоплюємо
 *
 * @function:   адреса функції-обертки, яка буде викликатися замість
 * перехопленої функції
 *
 * @original:   вказівник на місце, куди слід записати адресу
 * перехоплюваної функції, що заповнюється при установці
 *
 * @address:    адреса функції, що перехоплюється, з'ясовується при установці
 *
 * @ops:        службова інформація ftrace, ініціалізується нулями,
 * при установці перехоплення буде доініціалізована
 */
struct ftrace_hook 
{
        const char *name;
        void *function;
        void *original;

        unsigned long address;
        struct ftrace_ops ops; 
};
Користувачеві необхідно заповнити лише перші три поля: name, function, original. Інші поля вважаються деталлю реалізації. Опис всіх перехоплюваних функцій можна зібрати в масив і використовувати макроси, щоб підвищити компактність коду:

#define HOOK(_name, _function, _original)       \
        {                                       \
            .name = (_name),                    \
            .function = (_function),            \
            .original = (_original),            \
        }

static struct ftrace_hook hooked_functions[] = 
{
        HOOK("sys_clone",   fh_sys_clone,   &real_sys_clone),
        HOOK("sys_execve",  fh_sys_execve,  &real_sys_execve),
};
Обгортки над функціями, що перехоплюються, виглядають наступним чином:

/*
 * Це вказівник на оригінальний обробник системного виклику execve().
 * Його можна викликати з обгортки. Дуже важливо в точності дотримуватися
 * сигнатуру функції: порядок і типи аргументів і значення, що повертається,
 * а також специфікатори ABI (увага на "asmlinkage").
 */
static asmlinkage long (*real_sys_execve)(const char __user *filename,
                const char __user *const __user *argv,
                const char __user *const __user *envp);

/*
 * Ця функція буде викликатися замість перехопленої. Її аргументи – це
 * аргументи оригінальної функції. Її значення, що повертається, буде передано
 * Викликає функції. Вона може виконувати довільний код до, після
 * або замість оригінальної функції.
 */
static asmlinkage long fh_sys_execve(const char __user *filename,
                const char __user *const __user *argv,
                const char __user *const __user *envp)
{
        long ret;

        pr_debug("execve() called: filename=%p argv=%p envp=%p\n",
                filename, argv, envp);

        ret = real_sys_execve(filename, argv, envp);

        pr_debug("execve() returns: %ld\n", ret);

        return ret;
}
```
Як бачимо, функції, що перехоплюються з мінімумом зайвого коду. Єдиний момент, який потребує ретельної уваги – це сигнатури функцій. Вони мають збігатися один до одного. Без цього, очевидно, аргументи передадуть неправильно і все піде під укіс. Для перехоплення системних викликів це важливо меншою мірою, оскільки їх обробники дуже стабільні й у ефективності аргументи приймають у тому порядку, як і самі системні виклики. Однак, якщо ви плануєте перехоплювати інші функції, слід пам'ятати про те, що всередині ядра стабільних інтерфейсів немає .

Ініціалізація ftrace

Для початку нам потрібно знайти і зберегти адресу функції, яку ми перехоплюватимемо. Ftrace дозволяє трасувати функції на ім'я, але нам все одно треба знати адресу оригінальної функції, щоб викликати її.

Здобути адресу можна за допомогою kallsyms - списку всіх символів в ядрі. Цей список містить всі символи, які не тільки експортуються для модулів. Отримання адреси функції, що перехоплюється, виглядає приблизно так:
```sh
static int resolve_hook_address(struct ftrace_hook *hook)
{
        hook->address = kallsyms_lookup_name(hook->name);

        if (!hook->address) {
                pr_debug("unresolved symbol: %s\n", hook->name);
                return -ENOENT;
        }

        *((unsigned long*) hook->original) = hook->address;

        return 0;
}
```
Далі необхідно ініціалізувати структуру ftrace_ops. У ній обов'язковим полем є лише func , що вказує на колббек, але нам також необхідно встановити деякі важливі прапори:
```sh
int fh_install_hook(struct ftrace_hook *hook)
{
        int err;

        err = resolve_hook_address(hook);
        if (err)
                return err;

        hook->ops.func = fh_ftrace_thunk;
        hook->ops.flags = FTRACE_OPS_FL_SAVE_REGS
                        | FTRACE_OPS_FL_IPMODIFY;

        /* ... */
}
```
fh_ftrace_thunk () - це наш коллбек, який ftrace буде викликати при трасуванні функції. Про нього згодом. Прапори, які ми встановлюємо, будуть потрібні для виконання перехоплення. Вони наказують ftrace зберегти та відновити регістри процесора, вміст яких ми зможемо змінити в колббеку.

Тепер ми готові до перехоплення. Для цього необхідно спочатку включити ftrace для цікавої для нас функції за допомогою ftrace_set_filter_ip(), а потім дозволити ftrace викликати наш коллбек за допомогою register_ftrace_function():
```sh
int fh_install_hook(struct ftrace_hook *hook)
{
        /* ... */

        err = ftrace_set_filter_ip(&hook->ops, hook->address, 0, 0);
        if (err) {
                pr_debug("ftrace_set_filter_ip() failed: %d\n", err);
                return err;
        }

        err = register_ftrace_function(&hook->ops);
        if (err) {
                pr_debug("register_ftrace_function() failed: %d\n", err);

                /* Не забуваймо вимкнути ftrace у разі помилки. */
                ftrace_set_filter_ip(&hook->ops, hook->address, 1, 0);

                return err;
        }

        return 0;
}
```
Вимикається перехоплення аналогічно, тільки у зворотному порядку:
```sh
void fh_remove_hook(struct ftrace_hook *hook)
{
        int err;

        err = unregister_ftrace_function(&hook->ops);
        if (err) {
                pr_debug("unregister_ftrace_function() failed: %d\n", err);
        }

        err = ftrace_set_filter_ip(&hook->ops, hook->address, 1, 0);
        if (err) {
                pr_debug("ftrace_set_filter_ip() failed: %d\n", err);
        }
}
```
Після завершення виклику unregister_ftrace_function() гарантується відсутність активацій встановленого коллбека в системі (а разом з ним і наших обгорток). Тому ми можемо, наприклад, спокійно вивантажити модуль-перехоплювач, не побоюючись, що в системі ще виконуються наші функції (адже якщо вони пропадуть, то процесор засмутиться).

Виконання перехоплення функцій

Як же виконується власне перехоплення? Дуже просто. Ftrace дозволяє змінювати стан регістрів після виходу з колбека. Змінюючи регістр %rip - покажчик на наступну інструкцію, що виконується,- ми змінюємо інструкції, які виконує процесор - тобто можемо змусити його виконати безумовний перехід з поточної функції в нашу. Таким чином, ми перехоплюємо управління на себе.

Коллбек для ftrace виглядає так:
```sh
static void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip,
                struct ftrace_ops *ops, struct pt_regs *regs)
{
        struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);

        regs->ip = (unsigned long) hook->function;
}
```
За допомогою макросу container_of() ми отримуємо адресу нашої struct ftrace_hookза адресою впровадженою в неї struct ftrace_ops, після чого замінюємо значення регістру %rip у структурі struct pt_regsна адресу нашого оброблювача. Все. Для архітектур, відмінних від x86_64, цей регістр може називатися по-іншому (на зразок IP або PC), але ідея в принципі застосовна і для них.

Зверніть увагу на специфікатор notrace , доданий для колббека. Їм можна помічати функції, які заборонені для трасування за допомогою ftrace. Наприклад, так позначені функції самого ftrace, задіяні у процесі трасування. Це допомагає запобігти зависанню системи в безкінечному циклі при трасуванні всіх функцій в ядрі (ftrace так уміє).

Коллбек ftrace зазвичай викликає з відключеним витісненням (як і kprobes). Можливі винятки, але не варто розраховувати. У нашому випадку, правда, це обмеження не важливо, так ми лише замінюємо вісім байтів у структурі.

Функція-обгортка, що викликається пізніше, виконуватиметься у тому контексті, як і оригінальна функція. Тому там можна робити те саме, що дозволено робити в функції, що перехоплюється. Наприклад, якщо ви перехоплюєте обробник переривання, спати в обгортці все ще не можна.

Захист від рекурсивних викликів

У коді вище є каверза: коли наша обгортка викличе оригінальну функцію, та знову потрапить у ftrace, який знову викличе наш коллбек, який знову передасть управління обгортці. Цю нескінченну рекурсію треба якось обірвати.

Найбільш елегантний спосіб, який прийшов нам на думку - це використовувати parent_ip- один з аргументів ftrace-коллбека, який містить адресу повернення в функцію, яка викликала функцію, що трасується. Зазвичай, цей аргумент використовують для побудови графа викликів функцій. Ми можемо скористатися ним у тому, щоб відрізнити перший виклик перехопленої функції від повторного.

Дійсно, при повторному виклику parent_ipповинен вказувати всередину нашої обгортки, тоді як за першого — кудись в інше місце ядра. Передавати керування слід лише при першому виклику функції, всі інші повинні дати виконати оригінальну функцію.

Перевірку на входження можна дуже ефективно виконати, порівнюючи адресу з межами поточного модуля (який містить усі наші функції). Це добре працює у випадку, якщо в модулі лише обгортка викликає перехоплену функцію. В іншому випадку необхідно бути більш вибірковим.

Отже, правильний ftrace-коллбек виглядає так:
```sh
static void notrace fh_ftrace_thunk(unsigned long ip, unsigned long parent_ip,
                struct ftrace_ops *ops, struct pt_regs *regs)
{
        struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops);

        /* Пропускаємо дзвінки функції з поточного модуля. */
        if (!within_module(parent_ip, THIS_MODULE))
                regs->ip = (unsigned long) hook->function;
}
```
Відмінні риси/переваги даного підходу:

Найнижчі накладні витрати. Лише кілька віднімань і порівнянь. Жодних спінлок, проходів за списками, і так далі. Не потребує глобального стану. Відсутність синхронізації робить подібний підхід автоматично сумісним із витісненням. Він не прив'язаний до глобального списку процесів, тому дозволяє перехоплювати в тому числі обробники переривань. Немає обмежень на функції. Цей підхід позбавлений нестачі кретівпроби і з коробки підтримує будь-яку кількість активацій перехоплюваної функції, у тому числі рекурсивних (коли ядро ​​саме викликає функцію кілька разів). При рекурсивних викликах адреса повернення все ще знаходиться поза нашим модулем, так що перевірка в колббеку працює коректно.

Схема роботи перехоплення

Розглянемо приклад: ви набрали в терміналі команду ls щоб побачити список файлів у поточній директорії. Командний інтерпретатор (скажімо, Bash) для запуску нового процесу використовує традиційну пару функцій fork () + execve () із стандартної бібліотеки мови Сі. Всередині ці функції реалізуються через системні виклики clone() та execve() відповідно. Допустимо, ми перехоплюємо системний виклик execve(), щоб контролювати запуск нових процесів. Процес користувача виконує SYSCALL. За допомогою цієї інструкції виконується перехід у режим ядра і керування передається низькорівневому обробнику системних викликів – entry_SYSCALL_64 (). Він відповідає за всі системні виклики 64-розрядних програм на 64-розрядних ядрах. Управління переходить до конкретного оброблювача. Ядро швидко робить низькорівневі відносини, реалізовані асемблері , і передає управління високорівневої функції do_syscall_64 (), написаної на Сі . Ця функція звертається до таблиці обробників системних викликів sys_call_tableі викликає звідти конкретний обробник за номером системного виклику — у нашому випадку це буде функція sys_execve (). Викликається ftrace. На початку кожної функції ядра знаходиться виклик функції fentry (), яка реалізується фреймворком ftrace. У функціях, які трасувати не треба, цей виклик зазвичай замінений на інструкції nop , але в цікавій для нас функції sys_execve() цей виклик присутній. Ftrace викликає наш колббек. У процесі роботи ftrace викликає усі зареєстровані трасувальні колббеки, включаючи і наш. В одному місці може бути встановлений лише один колббек, що змінює значення регістру %rip, так що інші коллбеки нам не завадять. Коллбек виконує перехоплення. Коллбек дивиться на значення parent_ip, що вказує всередину do_syscall_64() — оскільки саме ця функція викликала обробник sys_execve() — і вирішує виконати перехоплення, оновлюючи значення регістру %rip у структурі pt_regs. Ftrace відновлює регістри. Наслідуючи прапор FTRACE_SAVE_REGS, ftrace зберігає стан регістрів у структурі pt_regsперед викликом обробників. При завершенні обробки ftrace відновлює регістри цієї структури. Наш обробник змінює регістр %rip - покажчик на наступну інструкцію, що виконується - що в результаті призводить до передачі управління за новою адресою. Управління отримує функція обгортка. Через безумовного переходу активація функції sys_execve() ніби переривається. Замість її управління отримує наша функція fh_sys_execve (). При цьому решта стану процесора і пам'яті залишається без змін, тому наша функція отримує всі аргументи оригінального оброблювача і при завершенні поверне управління в функцію do_syscall_64(). Обгортка викликає оригінальну функцію. З цього моменту доля системного виклику перебуває у наших руках. Функція fh_sys_execve() може проаналізувати аргументи та контекст системного виклику (хто що запускає) та заборонити чи дозволити процесу його виконання. У разі заборони, функція просто повертає код помилки. Інакше їй слід викликати оригінальний обробник - sys_execve() викликається повторно, через покажчик real_sys_execve , який був збережений при налаштуванні перехоплення. Управління отримує колббек. Як і при першому виклику sys_execve(), керування знову проходить через ftrace і передається в наш колббек. Однак, цього разу ситуація розвивається трохи інакше… Коллбек нічого не робить. Тому що цей раз функція sys_execve() викликається нашою функцією fh_sys_execve(), а не ядром з do_syscall_64(). Тому колббек не модифікує регістри і виконання функції sys_execve() продовжується як завжди. Єдиний побічний ефект такої справи: ftrace бачить вхід до sys_execve() двічі. Управління повертається обгортці. Вдруге обробник системного виклику sys_execve() поверне керування на нашу функцію fh_sys_execve(). На цей момент новий процес вже майже запущений. Ми можемо подивитися, чи завершився виклик execve() з помилкою, вивчити свіжозапущений процес, зробити відповідні записи в балку, і т.д. Управління повертається до ядра. Нарешті fh_sys_execve() завершується і керування переходить до do_syscall_64(), яка вважає, що системний виклик був завершений як завжди. Ядро продовжує свої ядерні відносини. Управління повертається в процес користувача. Нарешті ядро ​​виконує інструкцію IRET (або SYSRET, але для execve() - завжди IRET), встановлюючи регістри для нового користувача процесу і переводячи центральний процесор в режим виконання коду користувача. Системний виклик (і запуск нового процесу) завершено.

Переваги та недоліки

У результаті ми отримуємо дуже зручний спосіб перехоплення будь-яких функцій в ядрі, який має наступні переваги:

Зрілий API та простий код. Використання готових інтерфейсів у ядрі значно спрощує код. Вся установка перехоплення вимагає пари викликів функцій, заповнення двох полів у структурі, та мааааленького шматочка магії в колббеку. Решта коду - це виключно бізнес-логіка, що виконується навколо перехопленої функції. Перехоплення будь-якої функції на ім'я. Для вказівки функції, що нас цікавить, достатньо написати її ім'я у звичайному рядку. Не потрібні якісь особливі реверанси з редактором зв'язків, аналіз внутрішніх структур даних ядра, сканування пам'яті, або щось подібне. Ми можемо перехопити будь-яку функцію (навіть не експортовану для модулів), знаючи лише її ім'я. Перехоплення сумісне з трасуванням. Очевидно, що цей спосіб не конфліктує з ftrace, тому з ядра все ще можна знімати дуже корисні показники продуктивності. Використання kprobes або сплайсинг може перешкодити механізмам ftrace.

Які ж недоліки цього рішення?

Вимоги до конфігурації ядра. Для успішного виконання перехоплення функцій за допомогою ftrace ядро ​​має надавати низку можливостей: Список символів kallsyms для пошуку функцій на ім'я фреймворк ftrace в цілому для виконання трасування опції ftrace, критично важливі для перехоплення

Всі ці можливості не є критичними для функціонування системи та можуть бути відключені у конфігурації ядра. Правда, зазвичай ядра, які використовуються популярними дистрибутивами, всі ці опції в собі все одно містять, тому що вони не впливають на продуктивність і корисні при налагодженні. Однак, якщо вам необхідно підтримувати якісь особливі ядра, слід мати на увазі ці вимоги. Накладні витрати на ftrace менші, ніж у kprobes (бо ftrace не використовує точки зупинки), але вони вищі, ніж у сплайсингу, зробленого вручну. Дійсно, динамічний ftrace - це і є по суті сплайсинг, тільки виконує "непотрібний" код ftrace та інші коллбеки. Обертаються функції повністю. Як і традиційний сплайсинг, цей підхід повністю обертає виклики функцій. Однак, якщо сплайсинг технічно можливо виконати в будь-якому місці функції, ftrace спрацьовує виключно при вході. Звичайно, зазвичай це не викликає складнощів і навіть навпаки зручно, але подібне обмеження іноді може бути недоліком. Подвійний виклик ftrace. Наведений вище підхід з аналізом покажчика parent_ipпризводить до повторного виклику ftrace для перехоплених функцій. Це додає трохи накладних витрат і може збивати показання інших трасувань, які будуть бачити вдвічі більше викликів. Цього недоліку можна уникнути, застосувавши трохи чорної магії: виклик ftrace розташований на початку функції, тому якщо адресу оригінальної функції зрушити вперед на 5 байтів (довжина інструкції call), то через ftrace можна перескочити. Розглянемо деякі недоліки докладніше.

Вимоги до конфігурації ядра

Для початку, ядра повинні підтримувати ftrace і kallsyms. Для цього мають бути включені такі опції:

```CONFIG_FTRACE CONFIG_KALLSYMS```

Потім ftrace повинна підтримувати динамічну модифікацію регістрів. За цю можливість відповідає опція

```CONFIG_DYNAMIC_FTRACE_WITH_REGS```

Далі, ядро, що використовується, повинно бути засноване на версії 3.19 або вище , щоб мати доступ до прапора FTRACE_OPS_FL_IPMODIFY. Більш ранні версії ядра теж можуть замінювати регістр %rip, але починаючи з 3.19 це слід робити тільки після встановлення даного прапора. Наявність прапора для старих ядер призведе до помилки компіляції, а відсутність для нових — до непрацюючого перехоплення.

Нарешті, для виконання перехоплення критичним є розташування виклику ftrace всередині функції: виклик повинен розташовуватися на самому початку до прологу функції (де виділяється місце під локальні змінні і формується стіковий кадр). Ця особливість архітектури враховується опцією

CONFIG_HAVE_FENTRY

Архітектура x86_64 підтримує цю опцію, а ось i386 – ні. Через обмеження архітектури i386 компілятор не може вставити виклик ftrace до прологу функції, тому на момент виклику ftrace стек функції вже виявляється модифікованим. У такому випадку для перехоплення недостатньо лише змінити значення регістру %eip — ще треба звернути всі дії, виконані в пролозі, які відрізняються від функції до функції.

Тому перехоплення за допомогою ftrace не підтримує 32-бітну архітектуру x86. В принципі, його можна було б реалізувати за допомогою певної чорної магії (генеруючи та виконуючи «антипролог»), але тоді постраждає технічна простота рішення, що є однією з переваг використання ftrace.







Хапаючи золоте кільце-0
Linux надає потужний і обширний API для додатків, але іноді цього недостатньо. Взаємодія з апаратним забезпеченням або виконання операцій, що вимагають доступу до привілейованої інформації в системі, потребують модуля ядра.

Модуль ядра Linux — це частина скомпільованого бінарного коду, яка вставляється безпосередньо в ядро Linux і працює в кільці 0, найнижчому і найменш захищеному кільці виконання в процесорі x86-64. Код тут працює повністю без перевірок, але працює з неймовірною швидкістю і має доступ до всього в системі.

Не для звичайних смертних
Написання модуля ядра Linux — не для слабкодухих. Змінюючи ядро, ви ризикуєте втратити дані та пошкодити систему. Код ядра не має звичайної страховки, якою користуються звичайні додатки Linux. Якщо у вас виникне помилка, це заблокує всю систему.

Гірше того, ваша проблема може не проявитися одразу. Блокування вашого модуля одразу після завантаження - це, мабуть, найкращий сценарій невдачі. Додаючи більше коду до вашого модуля, ви ризикуєте створити неконтрольовані цикли та витоки пам'яті. Якщо не бути обережним, це може продовжувати рости під час роботи вашої машини. Зрештою, важливі структури пам'яті і навіть буфери можуть бути перезаписані.

Традиційні парадигми розробки додатків можуть бути значною мірою відкинуті. Окрім завантаження та вивантаження вашого модуля, ви писатимете код, який реагує на системні події, а не працює за послідовним шаблоном. При розробці ядра ви пишете API, а не самі додатки.

У вас також немає доступу до стандартної бібліотеки. Хоча ядро надає деякі функції, як-от printk
 (що служить заміною printf) і kmalloc (який працює подібно до malloc), ви здебільшого залишаєтесь залежні від власних засобів. Крім того, коли ваш модуль вивантажується, ви відповідаєте за повне очищення після себе. Збирання сміття відсутнє.

Передумови
Перш ніж ми почнемо, нам потрібно переконатися, що у нас є правильні інструменти для роботи. Найголовніше, вам знадобиться Linux-машина. Знаю, це повна несподіванка! Хоча підійде будь-який дистрибутив Linux, у цьому прикладі я використовую Ubuntu 16.04 LTS, тому якщо ви користуєтесь іншим дистрибутивом, вам, можливо, доведеться трохи скоригувати команди встановлення.

По-друге, вам знадобиться або окрема фізична машина, або віртуальна машина. Я віддаю перевагу роботі у віртуальній машині, але це повністю на ваш розсуд. Я не раджу використовувати вашу основну машину, оскільки втрата даних може статися, коли ви зробите помилку. Я кажу коли, а не якщо, тому що ви, безсумнівно, заблокуєте свою машину принаймні кілька разів під час процесу. Ваші останні зміни коду можуть все ще бути в буфері запису, коли ядро панікує, тому можливо, що ваші вихідні файли можуть бути пошкоджені. Тестування у віртуальній машині усуває цей ризик.

І нарешті, вам потрібно знати хоча б трохи C. Середовище виконання C++ занадто велике для ядра, тому написання "голого" C є необхідним. Для взаємодії з апаратним забезпеченням знання деякого асемблера може бути корисним.

Встановлення середовища розробки
На Ubuntu нам потрібно виконати:

```sh apt-get install build-essential linux-headers-`uname -r` ```
Це встановить основні інструменти розробки та заголовки ядра, необхідні для цього прикладу.

Приклади нижче припускають, що ви працюєте як звичайний користувач, а не як root, але у вас є привілеї sudo. Sudo є обов'язковим для завантаження модулів ядра, але ми хочемо працювати поза root, коли це можливо.
вже існує чудовий список потенційних цілей: syscalls! Системні виклики (або system calls) - це функції ядра, які можна викликати з простору користувача, і вони необхідні для майже всього, що віддалено цікаве. Кілька поширених, про які ви, ймовірно, чули:
```sh 
open
read
write
close
execve
fork
kill
mkdir
```
Повний список системних викликів x86_64 можна побачити тут https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl. Додавання власної функціональності до будь-якої з цих функцій може бути дуже цікавим. Ми могли б перехоплювати виклики read до певних файлів і повертати щось інше, або додавати користувацькі змінні середовища за допомогою execve. Ми навіть могли б використовувати деякі невикористані сигнали в kill, щоб надсилати команди нашому rootkit для виконання певних дій.

Якщо ми хочемо зробити системний виклик, то маємо зберегти потрібний номер системного виклику в регістрі ```rax```, а потім викликати ядро за допомогою програмного переривання ```syscall```. Будь-які аргументи, які потрібні системному виклику, мають бути завантажені в певні регістри перед використанням переривання, а значення, що повертається, майже завжди розміщується в ```rax```.

Це найкраще проілюструвати на прикладі - візьмемо системний виклик ```0, sys_read (всі системні виклики мають префікс sys_)```. Якщо ми пошукаємо цей системний виклик за допомогою man 2 read, то побачимо, що він визначений як:

``` ssize_t read(int fd, void *buf, size_t count);```
```fd``` - це файловий дескриптор (повертається після виклику open()), ```buf``` - це буфер для зберігання прочитаних даних, а count - кількість байтів для зчитування. Значення, що повертається, - це кількість успішно прочитаних байтів, і є -1 при помилці.
У 64-бітних версіях ядра 4.17.0 і вище спосіб обробки системних викликів ядром змінився. Спочатку ми розглянемо старий метод, оскільки він все ще застосовується до дистрибутивів, як Ubuntu 16.04, а нова версія набагато легша для розуміння, коли старий спосіб зрозумілий.
З (64-бітною) версією ядра 4.17.0 це змінилося. Аргументи, які спочатку зберігаються в регістрах користувачем, копіюються в спеціальну структуру під назвою pt_regs, і це єдине, що передається системному виклику. Потім системний виклик відповідає за витягування потрібних аргументів з цієї структури. Згідно з ptrace.h https://github.com/torvalds/linux/blob/15bc20c6af4ceee97a1f90b43c0e386643c071b4/arch/x86/include/asm/ptrace.h#L12 , вона має наступну форму:
```sh
struct pt_regs {
    unsigned long bx;
    unsigned long cx;
    unsigned long dx;
    unsigned long si;
    unsigned long di;
    /* скорочено для ясності */
};
```
Це означає, що у випадку ```sys_read``` нам довелося б зробити щось на зразок:
```sh
asmlinkage long sys_read(const struct pt_regs *regs)
{
    int fd = regs->di;
    char __user *buf = regs->si;
    size_t count = regs->dx;
    /* решта функції */
}
```
Звичайно, справжній ```sys_read``` не потребує цього, оскільки ядро робить цю роботу за нас. Але нам потрібно буде обробляти аргументи таким чином, коли ми пишемо функцію-перехоплювач.
Посилання на сайт з хорошою базовою інформацією по руткітам https://xcellerator.github.io/tags/rootkit/ 
Посилання на гіт з гарними прикладами руткітів https://github.com/xcellerator/linux_kernel_hacking
Посилання на руткіт діаморфін https://github.com/m0nad/Diamorphine 

